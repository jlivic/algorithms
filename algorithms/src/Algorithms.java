import algorithms.codility.BinaryGap;
import algorithms.codility.CountDiv;
import algorithms.codility.CyclicRotation;
import algorithms.codility.FrogJmp;
import algorithms.codility.FrogRiverOne;
import algorithms.codility.MaxCounters;
import algorithms.codility.MissingInteger;
import algorithms.codility.OddOccurrencesInArray;
import algorithms.codility.PermMissingElem;
import algorithms.codility.TapeEquilibrium;

public class Algorithms {

	public static void main(String[] args) {
		
		//System.out.println(BinaryGap.Solution(1376796946));
		
//	    int [] A = {3, 8, 9, 7, 6};
//	    int K = 3;
//		System.out.println(CyclicRotation.solution(A, K));

//		int [] A = {9, 3, 9, 3, 9, 7, 9};
//		System.out.println(OddOccurrencesInArray.solution(A));
		
//		System.out.println(FrogJmp.solution(10, 85, 30));
		
//		int [] A = {2, 3, 1, 5};
//		System.out.println(PermMissingElem.solution(A));
		
//		int [] A = {3, 1, 2, 4, 3};
//		System.out.println(TapeEquilibrium.solution(A));
		
//		int X = 5;
//		int [] A = {1, 3, 1, 4, 2, 3, 5, 4};
//		System.out.println(FrogRiverOne.solution(X, A));
		
//		int N = 5;
//		int [] A = {3, 4, 4, 6, 1, 4, 4};
//		System.out.println(MaxCounters.solution(N, A));
		
//		int [] A = {-1, -3};
//		System.out.println(MissingInteger.solution(A));

		System.out.println(CountDiv.solution(101, 123000000, 2));
	}

}
